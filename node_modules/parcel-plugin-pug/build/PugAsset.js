"use strict";
const tslib_1 = require("tslib");
const Asset_1 = require("./Asset");
const HTMLAsset = require("parcel-bundler/lib/assets/HTMLAsset");
const load = require("pug-load");
const lexer = require("pug-lexer");
const parser = require("pug-parser");
const walk = require("pug-walk");
const linker = require("pug-linker");
const generateCode = require("pug-code-gen");
const wrap = require("pug-runtime/wrap");
const filters = require("pug-filters");
// A list of all attributes that may produce a dependency
// Based on https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
const ATTRS = {
    'src': [
        'script',
        'img',
        'audio',
        'video',
        'source',
        'track',
        'iframe',
        'embed'
    ],
    'href': ['link', 'a', 'use'],
    'srcset': ['img', 'source'],
    'poster': ['video'],
    'xlink:href': ['use'],
    'content': ['meta']
};
// A regex to detect if a variable is a 'pure' string (no evaluation needed)
const PURE_STRING_REGEX = /(^"([^"]+)"$)|(^'([^']+)'$)/g;
module.exports = class PugAsset extends Asset_1.Asset {
    constructor(name, pkg, options) {
        super(name, pkg, options);
        this.type = 'html';
    }
    parse(code) {
        let ast = load.string(code, {
            lex: lexer,
            parse: parser,
            filename: this.name
        });
        ast = linker(ast);
        ast = filters.handleFilters(ast);
        return ast;
    }
    collectDependencies() {
        walk(this.ast, node => {
            this.recursiveCollect(node);
            if (node.type === 'Tag') {
                const tag = node;
                if (tag.attrs) {
                    for (const attr of tag.attrs) {
                        const elements = ATTRS[attr.name];
                        if (elements && elements.indexOf(tag.name) > -1) {
                            if (PURE_STRING_REGEX.test(attr.val)) {
                                this.addURLDependency(attr.val.substring(1, attr.val.length - 1));
                            }
                        }
                    }
                }
            }
            return node;
        });
    }
    process() {
        const _super = name => super[name];
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield _super("process").call(this);
            const htmlAsset = new HTMLAsset(this.name, this.package, this.options);
            htmlAsset.contents = this.generated.html;
            yield htmlAsset.process();
            Object.assign(this, htmlAsset);
            return this.generated;
        });
    }
    generate() {
        const result = generateCode(this.ast, {
            compileDebug: false,
            pretty: !this.options.minify
        });
        return { html: wrap(result)() };
    }
    shouldInvalidate() {
        return false;
    }
    recursiveCollect(cNode) {
        if (cNode.type === 'Block') {
            cNode.nodes.forEach((n) => this.recursiveCollect(n));
        }
        else {
            if (cNode.filename && cNode.filename !== this.name && !this.dependencies.has(cNode.filename)) {
                this.addDependency(cNode.filename, {
                    name: cNode.filename,
                    includedInParent: true,
                });
            }
        }
    }
};
//# sourceMappingURL=PugAsset.js.map